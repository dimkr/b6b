////
This file is part of b6b.

Copyright 2017 Dima Krasner

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
////

b6b
===
Dima Krasner <dima@dimakrasner.com>
:Author Initials: DK
:numbered:
:website: https://github.com/dimkr/b6b

:toc:

Overview
--------
+b6b+ is a simple, dynamic, procedural and reflective scripting language
inspired by http://www.tcl.tk/[Tcl], http://www.python.org/[CPython], Lisp,
shell scripting and various ideas or views in western philosophy.

+b6b+ follows five design principles:

1. Everything is an object
2. Every object is a string
3. Every object is a procedure
4. Every statement is a procedure call
5. Transparent parallelism

Use Cases
~~~~~~~~~
+b6b+ is especially useful as:

1. A more powerful, yet simple alternative to shell scripting
2. A thin layer above C and system calls, which provides exceptions, garbage
   collection and a dynamic type system
3. An embedded interpreter in a big software project
4. An extremely lightweight scripting language, for rapid development of
   fault-tolerant embedded software

Tutorial
--------
[quote, 'Friedrich Nietzsche']
The doer alone learneth.

Metaphysics
~~~~~~~~~~~
In +b6b+, all objects are represented as strings:

--------------------------------------
Hello!
--------------------------------------

[quote, 'Thales']
All things are water.

Lists are also represented as strings; the list items are delimited by
whitespace:

--------------------------------------
This is a list with 7 items
--------------------------------------

List items which contain whitespace can be enclosed in braces to inform +b6b+
they should be treated as one list item:

--------------------------------------
{This is the first item} of a list
--------------------------------------

[quote, 'Anaximenes']
It differs in different substances in virtue of its rarefaction and
condensation.

Everything in 'b6b' is an object, including code. A piece of 'b6b' code is a
list of strings. Each string is a 'b6b' statement which instructs 'b6b' to
perform a certain operation. For example, the following script is a list of
three statements:

--------------------------------------
{$local a [$+ 1 2]}
{$stdout writeln {a b}}
{$exit 1}
--------------------------------------

Object Types
~~~~~~~~~~~~
There are two kinds of objects in +b6b+:

1. Anonymous objects
2. Named objects

Named objects have both a value and a name, while anonymous objects do not have
a name. To obtain the value of a named object, prefix its name with '$'.

Statements
~~~~~~~~~~
Each +b6b+ statement is a list of objects. The first object in a statement is
invoked, while the objects that follow are passed to it as parameters.

For example, the following script invokes the 'sleep' procedure (a named object)
to pause for '2' (an anonymous object) seconds:

--------------------------------------
{$sleep 2}
--------------------------------------

Return Values
^^^^^^^^^^^^^
Every procedure has a return value. The return value of the previously executed
procedure is called '_'. For example, the following script prints '7':

--------------------------------------
{$+ 4 3}
{$stdout writeln $_}
--------------------------------------

Invocation
^^^^^^^^^^
In addition, a statement can invoke another statemenet by enclosing it in
brackets:

--------------------------------------
{$stdout writeln [$+ 4 3]}
--------------------------------------

When this statement is invoked, +b6b+ invokes the internal statement '$+ 4 3',
assigns its return value in the outer statement and invokes '$stdout writeln 7'.

[quote, 'Vincent Van Gogh']
Great things are ... done by a series of small things brought together.

Naming Objects
~~~~~~~~~~~~~~
Anonymous objects can be assigned a name using either 'local' or 'global':

--------------------------------------
{$local sum [$+ 3 4]}
{$stdout writeln $sum}
--------------------------------------

Global objects are accessible by all procedures, while local objects cannot be
used outside of the procedure that created them.

Procedures
~~~~~~~~~~
New procedures can be created using 'proc', which receives the procedure name
and a list of statements:

--------------------------------------
{$proc say_hello {
	{$stdout writeln Hello!}
	{$stdout writeln [$+ 4 3]}
}}

{$say_hello}
--------------------------------------

The return value of a procedure is the return value of its last statement, or
the object passed to 'return':

--------------------------------------
{$proc say_hello {
	{$return [$+ 4 3]}
	{$stdout writeln {this statement is not executed}}
}}

{$say_hello}
--------------------------------------

Parameters
^^^^^^^^^^
A procedure may access its parameters through objects named '1', '2', etc':

--------------------------------------
{$proc say_hello {
	{$stdout writeln $1}
	{$stdout writeln [$+ 4 3]}
}}

{$say_hello Hello!}
--------------------------------------

Streams
~~~~~~~
Streams are external sources of data. For example, both files and timers are
represented as streams.

Typically, a stream can be read from or written to.

--------------------------------------
{$local a [$open /etc/hosts]}
{$stdout writeln [$a read]}
--------------------------------------

--------------------------------------
{$local a [$open file.txt w]}
{$stdout writeln Hello!}
--------------------------------------

Threads
~~~~~~~
+b6b+ allows multiple scripts to be executed in parallel. 'spawn' starts a
script in a separate thread of execution:

--------------------------------------
{$spawn {
	{$while 1 {
		{$stdout writeln 1}
	}}
}}

{$while 1 {
	{$stdout writeln 2}
}}
--------------------------------------

Since +b6b+ allows only one thread to run at a given moment, it is inefficient
to spawn threads to perform many short background operations. In such cases, use
'co':

--------------------------------------
{$while 1 {
	{$co {
		{$map i [$range 10 20] {
			{$stdout writeln $i}
		}}
	}}

	{$map i [$range 30 40] {
		{$stdout writeln $i}
	}}
}}
--------------------------------------

The list of statements passed to 'co' is put in a queue and a single thread
repeatedly pops and runs one item, until the queue is empty.

Event Loops
~~~~~~~~~~~
Event loops wait for events to occur and invoke an event handling procedure for
each event. For example, an event loop can 'read' a request from a network
connection, 'write' a response and terminate the connection, when a timer fires.

Event loops simplify development of programs that operate on multiple streams
concurrently.

Event loops are created using 'evloop' and managed using 'add', 'remove' and
'update'. In addition, procedures can be invoked after a given interval using
'after' or periodically, using 'every'.

--------------------------------------
{$global loop [$evloop]}

{$proc on_ping {
	{$stdout writeln {ping result:}}
	{$stdout write [$1 read]}
	{$loop after 10 $after_ping}
}}

{$proc after_ping {
	{$stdout writeln {after ping}}
}}

{$proc on_tick {
	{$loop add [$list.index [$sh {ls -la} 2]] $on_ls {} {}}
}}

{$proc on_ls {
	{$stdout writeln {files:}}
	{$stdout write [$1 read]}
}}

{$proc ctrl_c {
	{$stdout writeln bye}
	{$exit}
}}

{$loop add [$list.index [$sh {ping 127.0.0.1}] 2] $on_ping {} {}}
{$loop every 3 $on_tick}
{$loop add [$signal $SIGINT] $ctrl_c {} {}}
{$loop wait -1}
--------------------------------------

Standard Library
----------------
Core
~~~~
Interpreters
^^^^^^^^^^^^
--------------------------------------
{[$b6b {a b}] call {{$stdout writeln $@}}}
--------------------------------------

'b6b' creates a new interpreter with given global scope parameters. The
interpreter object provides a 'call' method, which runs a list of statements.

Object Names
^^^^^^^^^^^^
--------------------------------------
{$local number 5}
--------------------------------------

'local' assigns a name to object, in the local scope.

--------------------------------------
{$global number 5}
--------------------------------------

'global' assigns a name to object, in the global scope.

--------------------------------------
{$export number}
{$export number 5}
--------------------------------------

'export' assigns a name to object, in the calling scope. If no object is
specified, 'export' uses the object with the same name in the local scope.

Flow Control
^^^^^^^^^^^^
--------------------------------------
{$if [$== 4 3] {
	{$stdout writeln a}
} {
	{$stdout writeln b}
}}
--------------------------------------

'if' executes a list of statements if a condition is true. Otherwise, if the
condition is false and a second list of statements was specified, it is executed
instead.

--------------------------------------
{$return}
{$return 5}
--------------------------------------

'return' stops the execution of the currently running procedure and sets its
return value. If no return value is specified, the procedure returns an empty
string.

--------------------------------------
{$continue}
--------------------------------------

'continue' stops the current iteration of a loop.

--------------------------------------
{$break}
--------------------------------------

'break' stops the execution of a loop.

--------------------------------------
{$throw}
{$throw {error message}}
--------------------------------------

'throw' triggers an error condition. Error conditions are propagated until
caught by a 'try' block, or until they reach the global scope. In the latter
case, the script exits immediately with a non-zero exit code.

--------------------------------------
{$exit}
{$exit 1}
--------------------------------------

'exit' stops the execution of the script.

--------------------------------------
{$yield}
--------------------------------------

'yield' switches to another thread, if there is one.

[NOTE]
'yield' should be called only by threads that repeatedly check for a certain
condition, which is guaranteed to be false unless another thread performs some
action. For example, a thread that runs a loop which removes an item from a list
and performs a certain action on it, should call 'yield' every time the list is
empty, since no item will be added to the list until another thread has a chance
to do so. The 'yield' call improves efficiency because it allows the polling
thread to postpone the next iteration of its polling loop, when the polled
condition is guaranteed to be false if polled again immediately.

Strings
^^^^^^^
--------------------------------------
{$str.len abcd}
--------------------------------------

'str.len' returns the length of a string.

--------------------------------------
{$str.index abcd 2}
--------------------------------------

'str.index' returns the character at a given index within a string.

--------------------------------------
{$str.range abcd 0 2}
--------------------------------------

'str.range' returns a substring, identified by two indexes within a string.

--------------------------------------
{$str.join , {a b c}}
--------------------------------------

'str.join' joins a list of strings, with a delimiter.

--------------------------------------
{$str.split a,b,c ,}
--------------------------------------

'str.split' splits a string, by a delimiter.

--------------------------------------
{$str.expand {a\tb}}
--------------------------------------

'str.expand' expands escape sequences in a string.

--------------------------------------
{$rtrim {a b  }}
--------------------------------------

'rtrim' removes trailing whitespace from a string.

--------------------------------------
{$ltrim {a b  }}
--------------------------------------

'ltrim' removes leading whitespace from a string.

Lists
^^^^^
--------------------------------------
{$list.new a b c {d e}}
--------------------------------------

'list.new' creates a new list containing its arguments.

--------------------------------------
{$list.len {a b c}}
--------------------------------------

'list.len' returns the length of a list.

--------------------------------------
{$list.append $list f}
--------------------------------------

'list.append' appends an item to a list.

--------------------------------------
{$list.extend $list {f g}}
--------------------------------------

'list.extend' adds all items of a list to an existing list.

--------------------------------------
{$list.index {a b c} 0}
--------------------------------------

'list.index' returns the list item at a given index.

--------------------------------------
{$list.range {a b c d e f} 2 4}
--------------------------------------

'list.range' returns the items of a list, between two indices.

--------------------------------------
{$list.in a {a b c}}
--------------------------------------

'list.in' determines whether an item belongs to a list.

--------------------------------------
{$list.pop $list 1}
--------------------------------------

'list.pop' removes the item at a given index from a list.

--------------------------------------
{$choice {a b c}}
--------------------------------------

'choice' returns a pseudo-random list item.

Dictionaries
^^^^^^^^^^^^
--------------------------------------
{$dict.get {human 2 dog 4} snake 0}
--------------------------------------

'dict.get' returns the value associated with a dictionary key. If the key is
not found and a fallback value was specified, that value is returned. Otherwise,
an error condition is triggered.

--------------------------------------
{$dict.set $legs snake 0}
--------------------------------------

'dict.set' associates a value with a dictionary key. If the key already exists,
the value associated with it is replaced.

--------------------------------------
{$dict.unset $legs snake}
--------------------------------------

'dict.unset' removes a key from a dictionary.

Loops
^^^^^
--------------------------------------
{$map {a b} [$range 0 9] {
	{$+ $a $b}
}}
--------------------------------------

'map' receives a list of object names and a list, then repeatedly runs a list of
statements with local named objects that specify the next items of the list. The
return value of 'map' is a list of values returned by all iterations of the
loop.

[NOTE]
If an iteration of the loop calls 'continue', its return value is ignored.

--------------------------------------
{$while 1 {
	{$stdout writeln a}
}}
--------------------------------------

'while' repeatedly runs a list of statements, while a condition is true.

--------------------------------------
{$range 1 5}
--------------------------------------

'range' returns a list of all whole numbers in a given range.

Procedures
^^^^^^^^^^
--------------------------------------
{$proc append_stuff {
	{$list.append $. c}
	{$return $.}
} {a b}}
--------------------------------------

'proc' creates a new procedure. If optional private data is specified, it is
named '.' and preserved across procedure calls.

Exceptions
^^^^^^^^^^
--------------------------------------
{$try {
	{$/ 4 0}
} {
	{$stdout writeln $_}
} {
	{$stdout writeln {}}
}}
--------------------------------------

'try' receives a list of statements and runs it. If an error condition is
triggered, a second list of statements is executed. Finally, a third list of
statements is executed. If only one list of statements has been specified,
error conditions triggered by the first list of statements are silenced.

Evaluation
^^^^^^^^^^
--------------------------------------
{$eval {[$+ 4 5]}}
--------------------------------------

'eval' evaluates an expression.

--------------------------------------
{$repr {hello world}}
--------------------------------------

'repr' returns a human-readable, printable representation of an object.

--------------------------------------
{$call {
	{$stdout writeln a}
	{$stdout writeln b}
}}
--------------------------------------

'call' executes a list of statements.

Threading
^^^^^^^^^
--------------------------------------
{$spawn {
	{$while 1 {
		{$stdout writeln a}
	}}
}}
--------------------------------------

'spawn' executes a list of statements in a new thread.

--------------------------------------
{$co {
	{$map i [$range 1 20] {
		{$stdout writeln $i}
	}}
}}
--------------------------------------

'co' puts a list of statements in a queue. If the queue is empty, 'co' starts a
thread that calls each item in the queue, then exits.

[NOTE]
The statements must not block.

I/O
~~~
File System
^^^^^^^^^^^
--------------------------------------
{$realpath .}
--------------------------------------

'realpath' returns the absolute path of a file.

Streams
^^^^^^^
--------------------------------------
{$open file.txt rb}
--------------------------------------

'open' creates a file stream. The second argument may be 'r' (read),
'w' (create and write) or 'a' (create or append), but can be suffixed with '+'
(read and write), 'b' (to enable full buffering) or 'u' (to disable buffering).

[NOTE]
If no access mode is specified, the default is 'r' (line-buffered, read-only
access).

--------------------------------------
{$sem 5}
--------------------------------------

'sem' creates a semaphore stream.

--------------------------------------
{$sh {ls -la}}
--------------------------------------

'sh' creates pipe streams, attached to the standard I/O pipes of a shell
command.

--------------------------------------
{$signal $SIGTERM}
--------------------------------------

'signal' creates a signal stream.

--------------------------------------
{$timer 5.3}
--------------------------------------

'timer' creates a timer stream.

--------------------------------------
{$inet.client tcp 10.0.0.138 80}
--------------------------------------

'inet.client' creates a TCP or UDP client stream.

--------------------------------------
{$inet.server tcp 0.0.0.0 8000 5}
--------------------------------------

'inet.server' creates a TCP or UDP server stream.

--------------------------------------
{$un.client dgram /tmp/server}
--------------------------------------

'un.client' creates a Unix socket client stream.

--------------------------------------
{$un.server dgram /tmp/server 5}
--------------------------------------

'un.server' creates a Unix socket server stream.

Event Loops
^^^^^^^^^^^
--------------------------------------
{$evloop}
--------------------------------------

'evloop' creates a new event loop.

Bindings
~~~~~~~~
zlib
^^^^
--------------------------------------
{$deflate [[$open file.txt ru] read] 9}
--------------------------------------

'deflate' compresses a string.

--------------------------------------
{$inflate [$deflate [[$open file.txt ru] read]]}
--------------------------------------

'inflate' decompresses a string compressed using 'deflate'.

linenoise
^^^^^^^^^
--------------------------------------
{$linenoise.read {> }}
--------------------------------------

'linenoise.read' displays a prompt and reads a line of user input.

--------------------------------------
{$linenoise.add $line}
--------------------------------------

'linenoise.add' adds a line to the history of 'linenoise.read'.

--------------------------------------
{$linenoise.save history.txt}
--------------------------------------

'linenoise.save' saves the history of 'linenoise.read' to a file.

--------------------------------------
{$linenoise.load history.txt}
--------------------------------------

'linenoise.load' loads the history of 'linenoise.read' from a file.
